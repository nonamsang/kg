<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<link rel="stylesheet" th:href="@{/css/admin-chat.css}" />

<body
	th:replace="~{admin/layout :: layout(~{::section}, ~{::#page-scripts})}">

	<section>

		<!-- 좌측 채팅방 목록 -->
		<div class="chatroom_container">
			<a th:each="c : ${chatroom}" class="chatroom-card"
				th:onclick="|window.roomId = ${c.id}; window.loadRoom(); return false;|">
				<div class="chatroom-info">
					<div class="chatroom-name" th:text="${c.name}"></div>
					<div class="chatroom-lastmsg" th:text="${c.last_Message}"></div>
					<div class="chatroom-other" th:text="${c.other_User_Nickname}"></div>
				</div>
			</a>
		</div>

		<!-- 우측 채팅영역 -->
		<div class="chat_area">
			<div class="chat_container">

				<!-- ✅ 단일 리스트 컨테이너 -->
				<div id="msgs" class="chat_each_container">
					<!-- 과거 메시지 렌더링 -->
					<div class="msg" th:each="chat : ${chat}"
						th:with="isMe=${session.user_Id} == ${chat.sender}"
						th:classappend="${isMe} ? ' me' : null">
						

						<img th:if="${!isMe}"
							th:src="@{'/image/profile/' + ${otheruser.other_User_Profile}}"
							alt="profile" class="msg-profile">

						<div class="msg-body">
							<div class="meta" th:if="${!isMe}"
								th:text="${otheruser.other_User_Name}"></div>
							<div class="msg-bubble" th:text="${chat.content}"></div>
						</div>
					</div>
				</div>
			</div>


			<!-- 입력창 -->
			<div class="chat-input">
				<input id="msg" type="text" placeholder="메시지를 입력하세요" />
				<button onclick="send()">보내기</button>
			</div>
		</div>

		<script th:inline="javascript">
		// 전역 상태 (상대 정보 & 내 아이디)
		  window.roomId = null;
		  let MY_ID   = /*[[${session.user_Id}]]*/ 0; // 페이지 최초 진입 시 세션값
		  let OTHER_NAME = '상대';
		  let OTHER_PROFILE_URL = '/image/profile/default.png';

		  const chatArea = document.querySelector('.chat_area');
		  const msgs = document.getElementById('msgs');

		  // 1) 방 열기: 서버에서 JSON 가져오고 그리기
		  async function loadRoom() {
			
			connect();
			
		    const res = await fetch(`/admin/chat/data?roomId=${roomId}`, {
		      headers: { 'Accept': 'application/json' }
		    });

		    const data = await res.json();

		    MY_ID = data.myId;
		    
		    renderChat(data);
		  }

		  // 2) 리스트 전체 렌더 (기존 지우고 다시 그림)
		  function renderChat(data) {
		    OTHER_NAME = data?.otheruser?.other_User_Name || '상대';
		    OTHER_PROFILE_URL = data?.otheruser?.other_User_Profile
		      ? `/image/profile/${data.otheruser.other_User_Profile}`
		      : '/image/profile/default.png';

		    // 기존 메시지 삭제 (서버 렌더와 겹치게 싫으면 이 줄 주석처리)
		    msgs.innerHTML = '';

		    (data.chat || []).forEach(m => appendMessage(m, MY_ID));
		    
		   

		    // 맨 아래로 스크롤
		    msgs.scrollTop = msgs.scrollHeight;
		  }

		  // 3) 한 줄 추가 (과거 메시지/웹소켓 수신 공용)
		  function appendMessage(m, myIdFromData = MY_ID) {
		    const isMe = Number(m.sender) === Number(myIdFromData);

		    const row = document.createElement('div');
		    row.className = 'msg' + (isMe ? ' me' : '');

		    if (!isMe) {
		      const img = document.createElement('img');
		      img.className = 'msg-profile';
		      img.alt = 'profile';
		      img.src = OTHER_PROFILE_URL;
		      row.appendChild(img);
		    }

		    const body = document.createElement('div');
		    body.className = 'msg-body';

		    if (!isMe) {
		      const meta = document.createElement('div');
		      meta.className = 'meta';
		      meta.textContent = OTHER_NAME;
		      body.appendChild(meta);
		    }

		    const bubble = document.createElement('div');
		    bubble.className = 'msg-bubble';
		    bubble.textContent = m.content ?? '';
		    body.appendChild(bubble);

		    row.appendChild(body);
		    msgs.appendChild(row);
		    msgs.scrollTop = msgs.scrollHeight;
		  }
		  

		  let stomp, sub;
		  let reconnecting = false;

		  function connect() {
		  	console.log("룸은 :" +roomId);
		  	const sock = new SockJS('/ws-chat');
		  	stomp = Stomp.over(sock);

		  	// ① STOMP 디버그 출력: SEND/SUBSCRIBE/MESSAGE 프레임을 콘솔에 다 보여줌
		  	stomp.debug = (str) => console.log('[STOMP]', str);

		  	stomp.connect({}, () => {
		  		console.log('✅ STOMP connected?', stomp.connected);

		  		// ② 구독 설정 (서버가 convertAndSend("/topic/rooms/"+roomId) 로 보내는지 꼭 확인!)
		  		
		  		
		  		const dest = `/topic/rooms/${roomId}`;
		  		console.log('🔔 SUBSCRIBE to', dest);
		  		if (sub) sub.unsubscribe();
		  		sub = stomp.subscribe(dest, (frame) => {
		  			console.log('📥 RECEIVED FRAME', frame);            // 헤더/바디 다 보임
		  			try {
		  				const m = JSON.parse(frame.body);
		  				console.log('📩 PARSED MSG', m);
		  				appendMessage(m);                                 // 화면에 추가
		  			} catch (e) {
		  				console.error('JSON parse error', e, frame.body);
		  			}
		  		});

		  	}, (err) => {
		  		console.error('❌ STOMP connect error', err);
		  	});

		  	sock.onclose = scheduleReconnect;
		  }

		  function scheduleReconnect() {
		  	if (reconnecting) return;
		  	reconnecting = true;
		  	console.log('reconnect 시도중');
		  	setTimeout(() => {reconnecting = false; connect();}, 3000);
		  }

		  function send() {
			console.log("룸아이디: " + roomId);
		  	const input = document.getElementById('msg');
		  	const text = input.value.trim();
		  	if (!text) return;

		  	if (!stomp || !stomp.connected) {
		  		return console.warn('⚠️ 아직 연결 안됨. connect() 먼저 실행하세요.');
		  	}

		  	const payload = {
		  		type: 'SEND',
		  		chat_Room_Id: roomId,   // 서버 VO 필드명과 100% 동일해야 함
		  		sender: MY_ID,                  
		  		content: text
		  	};

		  	console.log('➡️ SEND payload', payload);
		  	stomp.send('/app/chat.send', {}, JSON.stringify(payload));
		  	input.value = '';
		  }
	  
		</script>

		<script
			src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>

		<script
			src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

		<th:block id="page-scripts"></th:block>
	</section>
</body>

</html>