<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<link rel="stylesheet" th:href="@{/css/admin-chat.css}" />

<body th:replace="~{admin/layout :: layout(~{::section}, ~{::#page-scripts})}">

	<section>

		<!-- 좌측 채팅방 목록 -->
		<div class="chatroom_container">
			<a th:each="c : ${chatroom}" class="chatroom-card"
				th:onclick="|window.roomId = ${c.id}; window.loadRoom(); return false;|">
				<div class="chatroom-info">
					<div class="chatroom-name" th:text="${c.name}"></div>
					<div class="chatroom-lastmsg" th:text="${c.last_Message}"></div>
					<div class="chatroom-other" th:text="${c.other_User_Nickname}"></div>
				</div>
			</a>
		</div>

		<!-- 우측 채팅영역 -->
		<div class="chat_area">
			<div class="chat_container">

				<!-- ✅ 단일 리스트 컨테이너 -->
				<div id="msgs" class="chat_each_container">
					<!-- 과거 메시지 렌더링 -->
					<div class="msg" th:each="chat : ${chat}" th:with="isMe=${session.user_Id} == ${chat.sender}"
						th:classappend="${isMe} ? ' me' : null">


						<img th:if="${!isMe}" th:src="@{'/image/profile/' + ${otheruser.other_User_Profile}}"
							alt="profile" class="msg-profile">

						<div class="msg-body">
							<div class="meta" th:if="${!isMe}" th:text="${otheruser.other_User_Name}"></div>
							<div class="msg-bubble" th:text="${chat.content}"></div>
						</div>
					</div>
				</div>
			</div>


			<!-- 입력창 -->
			<div class="chat-input">
				<input id="msg" type="text" placeholder="메시지를 입력하세요" />
				<button onclick="send()">보내기</button>
			</div>
		</div>

		<script th:inline="javascript">
			// 전역 상태 (상대 정보 & 내 아이디)
			window.roomId = null;
			let MY_ID = /*[[${session.user_Id}]]*/ 0; // 페이지 최초 진입 시 세션값
			let OTHER_NAME = '상대';
			let OTHER_PROFILE_URL = '/image/profile/default.png';

			const chatArea = document.querySelector('.chat_area');
			const msgs = document.getElementById('msgs');

			// 1) 서버에서 JSON으로 data 가져오기, 커넥트
			async function loadRoom() {

				connect();

				const res = await fetch(`/chat/data?roomId=${roomId}`/*컨트롤러에서 json으로 값 받아오기*/, {
					headers: {'Accept': 'application/json'} // json으로 값을 받아오겟다는 약속
				});

				const data = await res.json(); //controller에서 json으로 넘어온 값 파싱

				renderChat(data); // renderchat 함수에 data를 넣음 
			}

			// 2) 기본 정보 넣고 채팅 불러오기
			function renderChat(data) {

				MY_ID = data.myId; // data에서 받아온 값을 MY_ID에 넣음
				OTHER_NAME = data?.otheruser?.other_User_Name || '상대'; //other_User_Name 가져오고 없으면 널가드
				OTHER_PROFILE_URL = data?.otheruser?.other_User_Profile
					? `/image/profile/${data.otheruser.other_User_Profile}` : '/image/profile/default.png';

				msgs.innerHTML = ''; // 기존 메세지 삭제

				(data.chat || []).forEach(m => appendMessage(m, MY_ID));
				// data에서 가져온 chat 만큼 기존 chat 만드는 명령 반복

				msgs.scrollTop = msgs.scrollHeight;
				// 챗 생성되면 스크롤 올라가니 전부 생성 후엔 제일 밑으로 내려주기
			}

			// 3) chat메세지 한줄 만들기 (과거 메시지/ 웹소켓 수신 공용)
			function appendMessage(m, myIdFromData = MY_ID) {
				const isMe = Number(m.sender) === Number(myIdFromData);

				const row = document.createElement('div');
				row.className = 'msg' + (isMe ? ' me' : '');
				//내 메세지라면 class = .msg.me 상대라면 .msg

				if (!isMe) { // 상대 메세지라면 프로필 사진 추가
					const img = document.createElement('img');
					img.className = 'msg-profile';
					img.alt = 'profile';
					img.src = OTHER_PROFILE_URL;
					row.appendChild(img);
				}

				const body = document.createElement('div');
				body.className = 'msg-body';

				if (!isMe) { // 상대 메세지라면 닉네임 표기
					const meta = document.createElement('div');
					meta.className = 'meta';
					meta.textContent = OTHER_NAME;
					body.appendChild(meta);
				}

				const bubble = document.createElement('div'); //메세지 만들어주기 (상대 메세지, 내 메세지 공통)
				bubble.className = 'msg-bubble';
				bubble.textContent = m.content ?? '';
				body.appendChild(bubble);

				row.appendChild(body);
				msgs.appendChild(row);
				msgs.scrollTop = msgs.scrollHeight;
			}


			let stomp, sub;
			let reconnecting = false;

			function connect() { //채팅방에 websorket 커넥트
				const sock = new SockJS('/ws-chat'); //websorketconfig에서 엔드포인트 가져오기
				stomp = Stomp.over(sock); //stomp 클라이언트로 감싸기

				stomp.debug = (str) => console.log('[STOMP]', str);

				stomp.connect({}, () => {
					console.log('✅ STOMP connected?', stomp.connected);


					const dest = `/topic/rooms/${roomId}`; //topic/rooms/${roomId}에 연결!!
					console.log('🔔 SUBSCRIBE to', dest); //연결 로그 찍기
					if (sub) sub.unsubscribe(); // 같은 방이 존재하다면 새 연결 만들지 않음!
					sub = stomp.subscribe(dest, (frame) => {
						console.log('📥 RECEIVED FRAME', frame);            // 헤더/바디 다 보임
						try {
							const m = JSON.parse(frame.body);
							//connect된 방에서 받은 메세지를 m에 넣음!! (자신의 메세지 포함)
							console.log('📩 PARSED MSG', m); // 메세지 로그 찍기
							appendMessage(m);  // 화면에 추가
						} catch (e) {
							console.error('JSON parse error', e, frame.body);
						}
					});

				}, (err) => {
					console.error('❌ STOMP connect error', err);
				});

				sock.onclose = scheduleReconnect;
			}

			function scheduleReconnect() {
				if (reconnecting) return;
				reconnecting = true;
				console.log('reconnect 시도중');
				setTimeout(() => {reconnecting = false; connect();}, 3000);
			}

			function send() {
				console.log("룸아이디: " + roomId);
				const input = document.getElementById('msg');
				const text = input.value.trim();
				if (!text) return;

				if (!stomp || !stomp.connected) {
					return console.warn('⚠️ 아직 연결 안됨. connect() 먼저 실행하세요.');
				}

				const payload = {
					type: 'SEND',
					chat_Room_Id: roomId,   // 서버 VO 필드명과 100% 동일해야 함
					sender: MY_ID,
					content: text
				};

				console.log('➡️ SEND payload', payload);
				stomp.send('/app/chat.send', {}, JSON.stringify(payload));
				input.value = '';
			}

		</script>

		<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>

		<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

		<th:block id="page-scripts"></th:block>
	</section>
</body>

</html>