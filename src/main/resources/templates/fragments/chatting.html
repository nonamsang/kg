<!-- templates/fragments/header.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<link rel="stylesheet" href="/css/userchat.css">
</head>


<body>
	<div id="chat-root" th:attr="data-userid=${session.user_Id}"></div>

	<!-- 고정된 + 버튼 -->
	<div id="open-chat" aria-label="채팅 열기" role="button">+</div>

	<!-- 채팅 패널: 처음엔 숨김 + floating 모드 -->
	<div class="chat_area floating hide">
		<!-- 처음엔 숨김 -->
		<div class="chat_container">
			<div id="msgs" class="chat_each_container">
				<!-- 기존 타임리프 렌더/JS 렌더 영역 -->
			</div>
		</div>

		<div class="chat-input">
			<input id="msg" type="text" placeholder="메시지를 입력하세요" />
			<button onclick="send()">보내기</button>
		</div>

		<div id="chat-newchat" class="hide">관리자와 채팅 연결</div>
	</div>
	
	<script th:inline="javascript">
		
		//set-user
		document.querySelectorAll('.set-user').forEach(link => { //forEach 돔에 있는 모든 set-user에 관해 이 명령을 수행
			link.addEventListener('click', function (e) { 
				e.preventDefault(); //페이지 맨 위로 점프, 혹은 링크로 이동하려는걸 막고 js 문법을 완전 비동기로 실행함
				const userId = this.dataset.id; // 위에 내가 인자로 설정해둔 dataset.id 가져옴
				
				console.log(/*[[${session.user_Id}]]*/); //session 값 변경 후에는 새로고침 해야 적용됨
				
				const headers = {'Content-Type': 'application/x-www-form-urlencoded'}; 
				//id=5와 같은 형식으로 보낼거라는 예고문, headers
				
				fetch('/set-user', {
					method: 'POST',
					headers, //id = 5 같은 형식으로 보낸다?
					body: `id=${userId}` //id = 5 같은 형식으로 보냄
				})
				.then(res => res.json()) //json으로 파싱
				.then(data => { //파싱한 값을 data에 넣음
					console.log(`세션 변경 완료: ${data.status}, user id: ${data.user_Id}`); 
				});
			});
		}); //set-user끝
		
		document.addEventListener('DOMContentLoaded', () => {
	    const openBtn   = document.getElementById('open-chat');
	    const chatArea  = document.querySelector('.chat_area');
	
		openBtn.addEventListener('click', onOpenChat);

	    async function onOpenChat() {
	      try {
	        // 1) 내 채팅방 개수 확인
	        const res = await fetch('/chat/user/chatroomcount');
	
	        // 숫자 응답을 JSON 혹은 text 둘 다 대응
	        let count;
	       	count = await res.text();
	
	        if (Number(count) == 0) {
	          const res = await fetch('/newchat', {
		          method: 'POST'
		      });
	        }
	        
	        connect();
	        
	        const panel   = document.querySelector('.chat_area.floating');
       		const willOpen = panel.classList.contains('hide');
       	    panel.classList.toggle('hide', !willOpen);
       	    panel.classList.toggle('open', willOpen);

            loadRoom().catch(console.error);
          
	      } catch (err) {
	        console.error(err);
	        alert('채팅 정보를 불러오지 못했어요.');
	      }
	    }
	  });
	</script>
	<script th:inline="javascript">
	  // 전역 상태 (상대 정보 & 내 아이디)
	  let roomId;
	  let MY_ID   = /*[[${session.user_Id}]]*/ 0; // 페이지 최초 진입 시 세션값
	  let OTHER_NAME = '상대';
	  let OTHER_PROFILE_URL = '/image/profile/default.png';
	
	  const chatArea = document.querySelector('.chat_area');
	  const msgs = document.getElementById('msgs');
	
	  // 1) 방 열기: 서버에서 JSON 가져오고 그리기, 커넥트
	  async function loadRoom() {
		//채팅방 아이디 가져오기
		const getRoomId = await fetch(`/getchatroomid`) 
		//가져온 채팅방 아이디 js 변수에 넣기
		roomId = await getRoomId.text();
		//기존 chat data 가져오기
	    const res = await fetch(`/chat/data?roomId=${roomId}`, {
	      headers: { 'Accept': 'application/json' }
	    });
	    if (!res.ok) throw new Error('HTTP ' + res.status);
		//json 파싱
	    const data = await res.json();
		//가져온 데이터 renderChat 함수로 넘기기
	    renderChat(data);
	   
	    //websorket 서버에 커넥트
	    connect();
	  }
	
	  // 2) 리스트 전체 렌더 (기존 지우고 다시 그림)
	  function renderChat(data) {
		  
		MY_ID = data.myId;
	    OTHER_NAME = data?.otheruser?.other_User_Name || '상대';
	    OTHER_PROFILE_URL = data?.otheruser?.other_User_Profile
	      ? `/image/profile/${data.otheruser.other_User_Profile}`
	      : '/image/profile/default.png';
	
	    // 기존 메시지 삭제
	    msgs.innerHTML = '';
		//채팅 데이터 개수만큼 함수 실행
		
	    (data.chat || []).forEach(m => appendMessage(m, MY_ID));
	    // 맨 아래로 스크롤
	    msgs.scrollTop = msgs.scrollHeight;
	  }
	
	  // 3) 한 줄 추가 (과거 메시지/웹소켓 수신 공용)
	  function appendMessage(m, myIdFromData = MY_ID) {
	    const isMe = Number(m.sender) === Number(myIdFromData);
	
	    const row = document.createElement('div');
	    row.className = 'msg' + (isMe ? ' me' : '');
	
	    if (!isMe) {
	      const img = document.createElement('img');
	      img.className = 'msg-profile';
	      img.alt = 'profile';
	      img.src = OTHER_PROFILE_URL;
	      row.appendChild(img);
	    }
	
	    const body = document.createElement('div');
	    body.className = 'msg-body';
	
	    if (!isMe) {
	      const meta = document.createElement('div');
	      meta.className = 'meta';
	      meta.textContent = OTHER_NAME;
	      body.appendChild(meta);
	    }
	
	    const bubble = document.createElement('div');
	    bubble.className = 'msg-bubble';
	    bubble.textContent = m.content ?? '';
	    body.appendChild(bubble);
	
	    row.appendChild(body);
	    msgs.appendChild(row);
	    msgs.scrollTop = msgs.scrollHeight;
	  }
	
	 
	</script>

	<script>
		
		let stomp, sub;
		let reconnecting = false;
		
		function connect() {
			const sock = new SockJS('/ws-chat');
			stomp = Stomp.over(sock);
		
			// ① STOMP 디버그 출력: SEND/SUBSCRIBE/MESSAGE 프레임을 콘솔에 다 보여줌
			stomp.debug = (str) => console.log('[STOMP]', str);
		
			stomp.connect({}, () => {
				console.log('✅ STOMP connected?', stomp.connected);
		
				// ② 구독 설정 (서버가 convertAndSend("/topic/rooms/"+roomId) 로 보내는지 꼭 확인!)
				
				
				const dest = `/topic/rooms/${roomId}`;
				console.log('🔔 SUBSCRIBE to', dest);
				if (sub) sub.unsubscribe();
				sub = stomp.subscribe(dest, (frame) => {
					console.log('📥 RECEIVED FRAME', frame);            // 헤더/바디 다 보임
					try {
						const m = JSON.parse(frame.body);
						console.log('📩 PARSED MSG', m);
						appendMessage(m);                                 // 화면에 추가
					} catch (e) {
						console.error('JSON parse error', e, frame.body);
					}
				});
		
			}, (err) => {
				console.error('❌ STOMP connect error', err);
			});
		
			sock.onclose = scheduleReconnect;
		}
		
		function scheduleReconnect() {
			if (reconnecting) return;
			reconnecting = true;
			console.log('reconnect 시도중');
			setTimeout(() => {reconnecting = false; connect();}, 3000);
		}
		
		function send() {
			const input = document.getElementById('msg');
			const text = input.value.trim();
			if (!text) return;
		
			if (!stomp || !stomp.connected) {
				return console.warn('⚠️ 아직 연결 안됨. connect() 먼저 실행하세요.');
			}
		
			const payload = {
				type: 'SEND',
				chat_Room_Id: roomId,
				sender: MY_ID,                  
				content: text
			};
		
			console.log('➡️ SEND payload', payload);
			stomp.send('/app/chat.send', {}, JSON.stringify(payload));
			input.value = '';
		}
	</script>

	<script
		src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>

	<script
		src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
	

</body>

</html>